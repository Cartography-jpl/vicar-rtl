//      Copyright (c) 1999, California Institute of Technology
//      U. S. Government sponsorship under NASA contract is acknowledged

//////////////////////////////////////////////////////////////////////////////
//
//				TdsQuery.h
//
//      TdsQuery is a class that prepares and sends a PVL query to a TDS.
//  The query can be an existing PVL file or can be generated by components.
//  Once the query has be created and sent, this is not needed for further
//  TDS interface effort.
//
//////////////////////////////////////////////////////////////////////////////

#include <iostream>
#include <string.h>

#include "DataSinkSocket.h"
#include "TdsQuery.h"
#include "return_status.h"

//////////////////////////////////////////////////////////////////////////////
//
//				issueQuery
//
//	Attaches to the specified Host/Port via a socket and transmits the
//  AMMOS SFDU wrapped PVL object.  The connection to the TDS is then
//  transfered/copied and used by the SFDU source object.
//
//////////////////////////////////////////////////////////////////////////////
int	TdsQuery::issueQuery(
  char	*Host,
  int	PortNumber,
  DataSourceSocket	&TdsSource)
{ int	Status;
  SocketBase		Port;
  DataSinkSocket	QUERY;

  if (!_pvlGenerated) return RTN_MISSING_DATA;

  Status = Port.open(Host,PortNumber);
  if (RTN_FAILURE(Status))
  { cerr << RTN_DFLT_MSG(Status) << " ... openning TDS query port\n";
    return (Status);
  } //  else cout << "Port opened\n";

  Status = QUERY.use(Port);
  if (RTN_FAILURE(Status))
  { cerr << RTN_DFLT_MSG(Status) << " ... X-fering port to Query\n";
    return (Status);
  }

  Status = TdsSource.use(Port);
  if (RTN_FAILURE(Status))
  { cerr << RTN_DFLT_MSG(Status) << " ... X-fering port to SFDU Source\n";
    return (Status);
  }

  Status = _pvlSfdu.sendSfdu(&QUERY);
  if (RTN_FAILURE(Status))
  { cerr << RTN_DFLT_MSG(Status) << " ... sending PVL SFDU\n";
    return (Status);
  } // else cout << RTN_DFLT_MSG(Status) << " ... sending PVL SFDU\n";

  return Status;
}

//////////////////////////////////////////////////////////////////////////////
//
//				loadPvlFromFile
//
//	Creates a PVL-SFDU object by read reading the specified file.  The
//  PVL file must only contain the PVL object and no SFDU headers/labels.
//
//////////////////////////////////////////////////////////////////////////////
int	TdsQuery::loadPvlFromFile(
  char	*PvlFile)
{ int	Status;

  Status = _pvlSfdu.ingestTdsPvlFile( PvlFile );
  if (RTN_SUCCESS(Status))
  { _pvlGenerated = 1;
    memset(_pvlBuffer,0,PVL_BUFFER_LTH);
    _pvlSfdu.extractPvlObject(_pvlBuffer,PVL_BUFFER_LTH);
  }

  return Status;
}

//////////////////////////////////////////////////////////////////////////////
//
//				loadPvlFromSfdu
//
//	Creates a PVL-SFDU object by extracting the PVL object from an
//  exisiting SFDU object.
//
//////////////////////////////////////////////////////////////////////////////
int	TdsQuery::loadPvlFromSfdu(
  SfduPvl	&Sfdu)
{ int	Status;

  memset(_pvlBuffer,0,PVL_BUFFER_LTH);
  Status = Sfdu.extractPvlObject(_pvlBuffer,PVL_BUFFER_LTH);
  if (RTN_SUCCESS(Status))
  { Status = _pvlSfdu.ingestTdsPvlBuffer(_pvlBuffer);
    if (RTN_SUCCESS(Status)) _pvlGenerated = 1;
  }

  return Status;
}

//////////////////////////////////////////////////////////////////////////////
//
//				savePvlToFile
//
//	Writes the PVL object to the specified disk file.  No SFDU labels
//  are written to the file.
//
//////////////////////////////////////////////////////////////////////////////
int	TdsQuery::savePvlToFile(
  char	*PvlFile)
{

  return RTN_NOT_IMPLEMENTED;
}

//////////////////////////////////////////////////////////////////////////////
//
//				generatePvlBuffer
//
//	Generates an ASCII PVL object from the component keyword/value pairs.
//
//////////////////////////////////////////////////////////////////////////////
int	TdsQuery::generatePvlBuffer( void )
{

  return RTN_NOT_IMPLEMENTED;
}

//////////////////////////////////////////////////////////////////////////////
//
//				setTimeRange
//
//	Sets the component values for the start/end times of a PVL object
//  when the values are given as the strings: "NOW" or "FOREVER", or as
//  a formatted time range, SCET, ERT, RCT or SCLK.
//
//////////////////////////////////////////////////////////////////////////////
void	TdsQuery::setTimeRange(
  int	type,
  char	*start,
  char	*stop)
{

  return;
}


//////////////////////////////////////////////////////////////////////////////
//
//				setTimeRange
//
//	Sets the component values for the start/end times of a PVL object
//  when the values can be stored as a UNIX time.
//
//////////////////////////////////////////////////////////////////////////////
void	TdsQuery::setTimeRange(
  int	type,
  time_t	*start,
  time_t	*stop)
{

  return;
}


//////////////////////////////////////////////////////////////////////////////
//
//				timeRange
//
//	Returns the specified time range as strings.
//
//////////////////////////////////////////////////////////////////////////////
void	TdsQuery::timeRange(
  char	*start,
  char	*stop)
{

  return;
}


//////////////////////////////////////////////////////////////////////////////
//
//				timeRange
//
//	Returns the specified time range as UNIX times.  This will not be
//  appropriate for some time ranges (e.g., SCLKs or the NOW/FOREVER values).
//
//////////////////////////////////////////////////////////////////////////////
void	TdsQuery::timeRange(
  time_t	*start,
  time_t	*stop)
{

  return;
}

//////////////////////////////////////////////////////////////////////////////
//
//				setDataType
//
//	Specifies the data type(s) to be queried from the TDS.  This value
//  must be defined in the TDS configuration, or the query will fail.
//
//////////////////////////////////////////////////////////////////////////////
void	TdsQuery::setDataType(
  char	*buffer)
{

  return;
}


//////////////////////////////////////////////////////////////////////////////
//
//				addDataType
//
//	Appends a data type to be queried from the TDS.
//
//////////////////////////////////////////////////////////////////////////////
void	TdsQuery::addDataType(
  char	*buffer)
{

  return;
}

